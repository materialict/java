//package src;
import java.util.ArrayList;

/* java persistance */
import java.io.Serializable;

public class uOperation extends generalFunctions implements Serializable{
	/**
	 * subfunctions must:
	 * - Return a status value
	 * - not use component variables
	 * - not use global variables
	 * - not use field values
	 * - all variables must be used
	 * - all parameters must be used
	 *
	 * if a component contains:
	 * - 1 entity with several fields it should be moved to a entity trigger
	 * - 1 entity and 1 field it should be moved to a field trigger
	 */

	boolean isEntry = false;

	String operationName = new String();

	ArrayList<uCodeLine> myCodeLines = new ArrayList<uCodeLine>();
	ArrayList<uParameter> myParams = new ArrayList<uParameter>();
	ArrayList<uVariable> myVariables = new ArrayList<uVariable>();

	uOperation(){
		/* constructor */
	}
	public void main(){
	}//main

	public void processOperation(){
		/* this function analyses the code lines and filter the data */

		/* validate operation */
		this.validateOperation();

		/* first get the name the function */
		this.operationName = this.getProcedureName();

		/* get the variables */
		this.getVariables();

		/* look if the variables are used in the code */
		this.checkUsageOfVariables();

		/* get the parameters */
		this.getParams();

		/* look if the parameters are used in the code */
		this.checkUsageOfParameters();
	}


	private String getProcedureName(){
		/* this function filters the name of ther entry or operation */

		/* the operation or entry name is always in the first line */
		String myLine = new String(this.myCodeLines.get(0).getProcessedLine());
		return myLine.substring(myLine.indexOf(" ", 0), myLine.length());

	}//endif


	private void validateOperation(){
		/* this function is a collaction of all different types of coding */

		/* the last line must be an end */
		uCodeLine myLine = this.myCodeLines.get(this.myCodeLines.size()-1);
		if (myLine.getProcessedLine().length() ==3
			&& myLine.getProcessedLine().equals("END")){
			/* no problem here */
		} else {
			/* no end tag found */
			myLine.setWarning(myLine.getCodeLineSuggestions(3010));
			this.myCodeLines.add(new uCodeLine(999, "END ; autogenerated content "));
		}
	}


	private void checkUsageOfVariables(){
		/* this function steps through the list of variables and determines if the exist
		in the processed class line. If the counter is less than two than the value is never used */

		/* step through the variables */
		for (int i =0; i < this.myVariables.size(); i++){
			String myVar = this.myVariables.get(i).getVariableName();
			int at = 0;
			int number = 0;

			/* step through the lines of code */
			for (int j =0; j < this.myCodeLines.size(); j++){
				String myLine = new String(this.myCodeLines.get(j).getProcessedLine());

				/* check if the codeline contains the variable */
				if(this.myCodeLines.get(j).commandInCodeLine(myVar)){
					/* yes it does */
					at++;
					if (at == 1){
						/* preserve the line number of the original defnition of the variable/parameter */
						number = j;
					}
				}
				if (at > 1){
					/* we found one more usage of the variable/parameter so we are done with this one */
					break;
				}
			}
			/* if the amount is 1, we have found only the definition of the variable */
			if (at == 1){
				uCodeLine myCode = this.myCodeLines.get(number);
				myCode.setWarning("Warning (5000): Variable " + myVar + " is never used in proc.");
			}
		}
	}//checkUsageOfVariables


	private void checkUsageOfParameters(){
		/* this function steps through the list of variables and determines if the exist
		in the processed class line. If the counter is less than two than the value is never used */

		/* step through the variables */
		for (int i =0; i < this.myParams.size(); i++){
			String myPar = this.myParams.get(i).getParameterName();
			int at = 0;
			int number = 0;

			/* step through the lines of code */
			for (int j = 0; j < this.myCodeLines.size(); j++){
				String myLine = new String(this.myCodeLines.get(j).getProcessedLine());

				/* check if the codeline contains the variable */
				if(this.myCodeLines.get(j).commandInCodeLine(myPar)){
					/* yes it does */
					at++;
					if (at == 1){
						/* preserve the line number of the original defnition of the variable/parameter */
						number = j;
					}
				}
				if (at > 1){
					/* we found one more usage of the variable/parameter so we are done with this one */
					break;
				}
			}
			/* if the amount is 1, we have found only the definition of the parameter */
			if (at == 1){
				uCodeLine myCode = this.myCodeLines.get(number);

				myCode.setWarning("Warning (5010): Parameter " + myPar + " is never used in proc.");
				at = 0;
				number = 0;

			}
		}
	}//checkUsageOfParameters


	public void getParams(){
		/* this function looks for the parameters block and processes it*/

		boolean isParams = false;

		/* look for the variabels defintion starter */
		for (int i = 0; i < this.myCodeLines.size(); i++){

			String myLine = new String(this.myCodeLines.get(i).getProcessedLine());


			if(myLine.length() == "PARAMS".length()
				&& myLine.equals("PARAMS")){

				isParams = true;

				while(isParams){

					/* get the next line */
					i++;
					myLine = new String(this.myCodeLines.get(i).getProcessedLine());

					/* if at the end of the variables block */
					if(myLine.length() == "ENDPARAMS".length()
						&& myLine.equals("ENDPARAMS")){
							isParams = false;
					} else if (myLine.isEmpty()){
						/* in this case do nothing and get the next line */

					} else {
						/* not yet at the end */
						myParams.add(new uParameter(myLine));

					}
				}
			}
		}
	}


	public void getVariables(){
		/* this function looks foor the local variables block and processes it*/

		boolean isVariables = false;

		/* look for the variabels defintion starter */
		for (int i = 0; i < this.myCodeLines.size(); i++){
			String myLine = new String(this.myCodeLines.get(i).getProcessedLine());
			if(myLine.length() == "VARIABLES".length()
				&& myLine.equals("VARIABLES")){

				isVariables = true;

				while(isVariables){
					/* process the variables */
					i++;
					myLine = new String(this.myCodeLines.get(i).getProcessedLine());

					/* if at the end of the variables block */
					if(myLine.length() == "ENDVARIABLES".length()
						&& myLine.equals("ENDVARIABLES")){
							isVariables = false;
					} else if (myLine.isEmpty()){
						/* in this case do nothing and get the next line */
					} else {
						/* not yet at the end */
						this.getVariables(myLine);
					}
				}
			}
		}
	}


	public void getVariables(String myLine){
		/* this function filters the string into seperate variable blocks
		a variable can be defined as:
			datatype variable1
		or
			datatype variable1, variable2, etc
		*/

		/* only if myline is filled */
		if (!myLine.isEmpty()){

			/* init */
			ArrayList<String> myList = new ArrayList<String>();
			myLine = myLine.trim();

			/* first look for the comma */
			if (myLine.indexOf(",", 0) > 0){
				myLine = myLine.replaceAll(", ", ",");

				/* comma found. The datatype contains more than 1 variable */
				String myDatatype = new String(myLine.substring(0, myLine.indexOf(" ", 0)));
				myLine = myLine.substring(myLine.indexOf(" ", 0));

				myList = this.splitString(myLine, ",");

				for (int i = 0; i < myList.size(); i++){
					myVariables.add(new uVariable(myDatatype, myList.get(i).trim()));
				}

			} else {
				/* no comma? then 1 variable with one datatype */
				myList = this.splitString(myLine, " ");
				myVariables.add(new uVariable(myList.get(1), myList.get(0)));
			}
		}
	}


	/*** getters and setters ***/
	public void setEntry(boolean isEntry){
		this.isEntry = isEntry;
	}
	public boolean getEntry(){
		return this.isEntry;
	}
	public String getOperationname(){
		return this.operationName;
	}

	public void setCodeline(uCodeLine myLine){
		this.myCodeLines.add(myLine);
	}
 }
